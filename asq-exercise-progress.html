<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../asq-base/asq-base.html">
<link rel="import" href="asq-exercise-progress-style.html">

<dom-module id="asq-exercise-progress">
  <template>
    <style include="iron-flex">
      :host {
        display: block;
        position: relative;
        @apply(--layout-horizontal);
        @apply(--layout-center);
        margin: 10px 0 5px 0;
      }
    </style>

    <style include="asq-exercise-progress-style"></style>

    <div class="progress-bar-container background-progress">
      <paper-progress id="background-submitted-progress" indeterminate style$=[[_calcFlex(submissionsNum)]]></paper-progress>
      <paper-progress id="background-working-progress" indeterminate style$=[[_calcFlex(_workingUsersNum)]]></paper-progress>
      <paper-progress id="background-focused-progress" indeterminate style$=[[_calcFlex(_focusedUsersNum)]]></paper-progress>
      <paper-progress id="background-idle-progress" indeterminate style$=[[_calcFlex(_idleUsersNum)]]></paper-progress>
    </div>

    <div class="progress-bar-container">
      <paper-progress id="submitted-progress" value="100" style$=[[_calcFlex(submissionsNum)]]></paper-progress>
      <paper-progress id="working-progress" value="100" style$=[[_calcFlex(_workingUsersNum)]]></paper-progress>
      <paper-progress id="focused-progress" value="100" style$=[[_calcFlex(_focusedUsersNum)]]></paper-progress>
      <paper-progress id="idle-progress" value="100" style$=[[_calcFlex(_idleUsersNum)]]></paper-progress>
    </div>

    <div id="progress-num">
      <span>[[submissionsNum]]</span>
      <span>/</span>
      <span>[[connectedViewersNum]]</span>
    </div>

  </template>

  <script>

  Polymer({

    is: 'asq-exercise-progress',

    behaviors: [ASQ.asqElementBehavior],

    properties: {

      /**
      * Object that contains users with their activity information.
      *
      * @attribute _users
      * @type Object
      * @default {}
      */
      _users: {
        type: Object,
        value: {},
      },

      /**
      * Counts the number of currently connected viewers.
      *
      * @attribute connectedViewersNum
      * @type Number
      * @default 0
      */
      connectedViewersNum: {
        type: Number,
        notify: true,
        value: 0,
      },

      /**
      * Counts the number of submissions, inherited from asq-exercise.
      *
      * @attribute submissionsNum
      * @type Number
      * @default 0
      */
      submissionsNum: {
        type: Number,
        value: 0,
      },

      /**
      * Counts the number of submissions during a given time interval
      * by the _visualizeChange function.
      *
      * @attribute _submissionCounter
      * @type Number
      * @default 0
      */
      _submissionCounter: {
        type: Number,
        value: 0,
      },

      /**
      * Counts the number of working users, calculated with the function given
      * in its computed property.
      * @attribute _workingUsersNum
      * @type Number
      * @default 0
      */
      _workingUsersNum:{
        type: Number,
        value: 0,
        computed: '_computeWorkingUsersNum(_users)',
      },

      /**
      * Counts the number of working users during a given time interval
      * by the _visualizeChange function.
      *
      * @attribute _workingCounter
      * @type Number
      * @default 0
      */
      _workingCounter: {
        type: Number,
        value: 0,
      },

      /**
      * Counts the number of focused users, calculated with the function given
      * in its computed property.
      * @attribute _focusedUsersNum
      * @type Number
      * @default 0
      */
     _focusedUsersNum:{
        type: Number,
        value: 0,
        computed: '_computeFocusedUsersNum(_users)',
     },

     /**
     * Counts the number of focused users during a given time interval
     * by the _visualizeChange function.
     *
     * @attribute _focusedCounter
     * @type Number
     * @default 0
     */
     _focusedCounter: {
       type: Number,
       value: 0,
     },

     /**
     * Counts the number of idle users, calculated with the function given
     * in its computed property.
     *
     * @attribute _focusedUsersNum
     * @type Number
     * @default 0
     */
     _idleUsersNum:{
        type: Number,
        value: 0,
        computed: '_computeIdleUsersNum(_users)',
     },

     /**
     * Counts the number of idle users during a given time interval
     * by the _visualizeChange function.
     *
     * @attribute _focusedCounter
     * @type Number
     * @default 0
     */
     _idleCounter: {
       type: Number,
       value: 0,
     },

    },

    /**
    * Computes the amount of working users from the _users object.
    *
    * @return {number} Number of working users.
    */
    _computeWorkingUsersNum: function() {
      let users = this._users;
      let num = Object.keys(users).reduce(function(acc, userId) {
        if(users[userId].working) return ++acc;
        return acc;
      }, 0);
      return num;
    },

    /**
    * Computes the amount of focused users from the _users object.
    *
    * @return {number} Number of focused users.
    */

    _computeFocusedUsersNum: function() {
      let users = this._users;
      return Object.keys(users).reduce(function(acc, userId) {
        if(users[userId].focused && !users[userId].idle) return ++acc;
        return acc;
      }, 0);
    },

    /**
    * Computes the amount of idle users from the _users object.
    *
    * @return {number} Number of idle users.
    */

    _computeIdleUsersNum: function() {
      let users = this._users;
      return Object.keys(users).reduce(function(acc, userId) {
        if(users[userId].idle || users[userId].disconnected) return ++acc
        return acc;
      }, 0);
    },

    /**
    * Returns a CSS declaration as a string to change the width of the progress bar
    * by changing its flex property.
    *
    * @param {number} The new flex value.
    * @return {string} String of the form "flex: num;"
    */
    _calcFlex: function(num) {
      return "flex:" + num + ";";
    },

    /**
    * If the given user is not already in the _users object, add him and notify
    * the observers that the _users object changed.
    *
    * @param {object} A user object.
    */
    _makeSureUserExists: function(userToFind) {
      this._users[userToFind.id] = this._users[userToFind.id] || userToFind;
      this._notifyPolymer();
    },

    /**
    * Mark the given user as working.
    *
    * @param {object} A user object.
    */
    _userWorked: function(user) {
      this._makeSureUserExists(user);
      if (!this._users[user.id].working) this._workingCounter++;
      this._resetUser(user);
      this._users[user.id].working = true;
      this._notifyPolymer();
    },

    /**
    * Mark the given user as focused.
    *
    * @param {object} A user object.
    */
    _userFocused: function(user) {
      this._makeSureUserExists(user);
      if (this._users[user.id].submitted) return;
      if (!this._users[user.id].focused) this._focusedCounter++;
      this._resetUser(user);
      this._users[user.id].focused = true;
      this._notifyPolymer();
    },

    /**
    * If the given user was idle, change his idle property and mark him as not idle.
    *
    * @param {object} A user object.
    */
    _userMadeTabVisible: function(user) {
      this._makeSureUserExists(user);
      this._users[user.id].idle = false;
      this._notifyPolymer();
    },

    /**
    * Mark the given user as idle.
    *
    * @param {object} A user object.
    */
    _userIdled: function(user) {
      this._makeSureUserExists(user);
      if (this._users[user.id].submitted) return;
      if (!this._users[user.id].idle) this._idleCounter++;
      this._resetUser(user);
      this._users[user.id].idle = true;
      this._notifyPolymer();
    },

    /**
    * If the given user was idle, change his idle property and mark him as not idle.
    *
    * @param {object} A user object.
    */
    _userMadeTabHidden: function(user) {
      this._makeSureUserExists(user);
      this._users[user.id].idle = false;
      this._notifyPolymer();
    },

    /**
    * If the given blurred, make sure that he's already in the _users object.
    *
    * @param {object} A user object.
    */
    _userBlurred: function(user) {
      this._makeSureUserExists(user);
    },

    /**
    * Reset all the activity properties of the given user.
    *
    * @param {object} A user object.
    */
    _resetUser: function(user) {
      this._users[user.id].working = false;
      this._users[user.id].focused = false;
      this._users[user.id].idle = false;
    },

    /**
    * Mark that the given user submitted and change the corresponding counter.
    *
    * @param {object} A user object.
    */
    _userSubmitted: function(user) {
      this._makeSureUserExists(user);
      this._resetUser(user);
      this._users[user.id].submitted = true;
      this._submissionCounter++;
    },

    /**
    * Change the number of connected users.
    *
    * @param {object} A user object.
    */
    _userConnected: function() {
      this.connectedViewersNum++;
    },


    /**
    * Change the number of connected users.
    *
    * @param {object} A user object.
    */
    _userDisconnected: function(user) {
      this.connectedViewersNum--;
      this._resetUser(user);
      this._notifyPolymer();
    },

    /**
    * Function to trigger the observers.
    *
    */
    _notifyPolymer: function() {
      _users = this._users;
      this._users = {};
      this._users = _users;
    },

    /**
    * Changes the css variable for the paper progress indeterminate cycle duration.
    *
    * @param {string} The css variable that will be changed.
    * @param {number} Duration of the animation cycle, given in seconds.
    */
    _setVelocity:  function(property, velocity) {
      let that = this;
      this.customStyle[property] = velocity + 's';
      this.updateStyles();
      setTimeout(function() {
        that.customStyle[property] = '0s';
        that.updateStyles();
      }, velocity * 1000);
    },

    /**
    * Animates the progress bar every 5 seconds depending on the activity.
    *
    */
    _visualizeChange: function() {
      let that = this;

      setInterval(function() {
        let submissionChange = that._calcChange(that._submissionCounter);
        let workingChange = that._calcChange(that._workingCounter);
        let focusedChange = that._calcChange(that._focusedCounter);
        let idleChange = that._calcChange(that._idleCounter);

        that._setVelocity('--submitted-bar-duration', that._determineVelocity(submissionChange));
        that._setVelocity('--working-bar-duration',  that._determineVelocity(workingChange));
        that._setVelocity('--focused-bar-duration',  that._determineVelocity(focusedChange));
        that._setVelocity('--idle-bar-duration',  that._determineVelocity(idleChange));

        that._submissionCounter = 0;
        that._workingCounter = 0;
        that._focusedCounter = 0;
        that._idleCounter = 0;
      }, 5000);
    },

    /**
    * Calculate the amount of change of a given activity.
    *
    * @param {number} A number that is smaller than or equal to the total number of users.
    * @return {number} The amount of change in percent and in proportion to the number of users.
    */
    _calcChange: function(num) {
      let total = this.submissionsNum + this._workingUsersNum + this._focusedUsersNum + this._idleUsersNum;
      return num/total * 100;
    },

    /**
    * Get the velocity for the paper progress indeterminate cycle.
    *
    * @param {number} A number in percent.
    * @return {number} Returns a number in seconds for the duration of one paper progress
    * indeterminate cycle.
    */
    _determineVelocity: function(num) {
      if (num == 0) return 0;
      else if(num < 5) return 10;
      else if(num < 15) return 8;
      else if(num < 30) return 6;
      else if(num < 50) return 4;
      else if(num < 75) return 2;
      else if(num <= 100) return 1;
      else return 0 // change was higher than 100%
    },

    created: function() {
      document.addEventListener('asq-ready', function(evt) {
        try {
          this._subscribeToEvents(evt.detail.asqEventBus);
        } catch (err) {
          console.debug('failed to _subscribeToEvents');
        }
      }.bind(this));
      this._visualizeChange();
    },

    _subscribeToEvents: function(eventBus) {
      eventBus.on('asq:sessionEventBeamer', function(evt) {
        const user = evt.data.sessionEvent.user;

        switch (evt.data.sessionEvent.type) {
          case 'folo-connected':
          case 'ghost-connected':
            return this._userConnected();
          case 'folo-disconnected':
          case 'ghost-disconnected':
          case 'ctrl-disconnected':
            return this._userDisconnected(user);
          case 'answer-submitted':
            return this._userSubmitted(evt.data.sessionEvent.answeree);
          case 'viewer-idle':
            return this._userIdled(user);
          case 'questioninput':
          case 'copy':
          case 'paste':
          case 'cut':
          case 'input':
            return this._userWorked(user);
          case 'tabvisible':
            return this._userMadeTabVisible(user);
          case 'tabhidden':
            return this._userMadeTabHidden(user);
          case 'focusin':
          case 'exercisefocus':
          case 'windowfocus':
            return this._userFocused(user);
          case 'exerciseblur':
          case 'windowblur':
            return this._userBlurred(user);
        }
      }.bind(this));
    },

  });

  </script>

</dom-module>
